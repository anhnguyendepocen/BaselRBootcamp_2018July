---
title: "Programming in R"
subtitle: ""
author: "The R Bootcamp<br/>Twitter: <a href='https://twitter.com/therbootcamp'>@therbootcamp</a>"
date: "April 2018"
output:
  xaringan::moon_reader:
    css: ["default", "my-theme.css"]
    lib_dir: libs
    nature:
      highlightStyle: github
      highlightLines: true
      countIncrementalSlides: false
      ratio: '16:9'
---

# ***Haven't we been programming in R for the last three days of the course?***
```{r setup, include=FALSE}
options(htmltools.dir.version = FALSE)
options(width=110)
options(digits = 4)
library(tidyverse)
library(yarrr)
```
---

# Content

.pull-left45[
Conditional Statements
- `if`, `else`
- `case_when`

Functions
- Program your own functions

Iteration
- `for` loops
- `while` loops
- `apply` functions
- `map` functions
]

.pull-right45[

```{r eval = FALSE}
my_var <- 1:5

# Conditional statement
if (length(my_var) < 6){
  my_var[5]
} else {
  print("'my_var' is too short.")
}

# Define own function
compute_circle_area <- function(radius){
  radius ** 2 * pi
}

# A for loop
for(i in seq_len(5)){
  mean(1:i)
}



```

]
---

# Conditional Statements

Allow you to conditionally execute code blocks.

.pull-left45[

*`if`; `else if`; and `else`*

`if` lets you check a condition. If this condition is `FALSE` you **can** (but don't have to!) add another check with `else if` that is then, if `TRUE`, executed. An `else` in the end means this code block is always executed if the above checks evaluated to `FALSE`, i.e. it doesn't include a check.


]

.pull-right45[

```{r eval=FALSE}

if (this) {
  
  # do this
  
} else if (that){
  
  # do that 
  
} else {
  
  # do something else
  
}

```

]


---

# A Note on Logical Expressions

.pull-left45[

The conditional statements often require you to specify checks (logical expressions) which have to evaluate to `TRUE` to execute the following block of code. Note that:

- `>`, `<`, `==`, `>=`, and `<=` are vectorized
- to prevent errors due to the vectorization use `any`, `all`, and `identical`

```{r}
x <- c(1:5)
x

y <- c(9:5)
y
```

]

.pull-right45[

```{r, eval=FALSE}

# uses only the first element of the
# check
if (x == y) print("x is equal to y")
# gives warning that only first element
# will be used

```

```{r}
# works because any only gives one
# statement back
if (any(x == y)) print("x is equal to y")

# all vs identical
all(c(1L, 2L, 3L) == c(1, 2, 3))
identical(c(1L, 2L, 3L), c(1, 2, 3))

```

]

---

# A Note on Logical Expressions

.pull-left45[

For multiple logical expressions you have to cue logical ands (`&`) or ors (`|`). Note that:

- `&` and `|` are vectorized
- `&&` and `||` are not vectorized and short-circuiting operations

]

.pull-right45[

```{r}
# checks the whole sequence
x <= y & x == y

# checks only the first element
x <= y && x == y

x <- NULL

!is.null(x) & x > 2

# && is short circuiting
!is.null(x) && x > 2



```

]

---

# Functions - General Structure

.pull-left45[

You can define your own functions. This can save a lot of time and space, because by writing your own function you only have to write the whole block of code once.

Benefits of writing code in functions:
- less typing
- fewer errors
- can be more general
- can be faster

]

.pull-right45[

```{r}
softmax <- function(dat, theta = 1){
  
  # check precondition and
  # return 0 if it's not met
  if (length(dat) == 0){
    return(0)
  }
  
  exp(dat * theta) / sum(exp(dat * theta))
  
}



```

]


---

# Functions - Return Statement

.pull-left45[

The last object in a function code is returned to the global environment. If a function call should be terminated in the middle of the code and some value be returned, the `return()` function has to be used.


]

.pull-right45[

```{r}
softmax <- function(dat, theta = 1){
  
  # check precondition and
  # return 0 if it's not met
  if (length(dat) == 0){
    return(0)
  }
  
  exp(dat * theta) / sum(exp(dat * theta))
  
}



```

]


---

# Functions - Arguments

.pull-left45[

Functions can take any object as input to arguments. Since functions themselves are also objects, this means that also functions can be passed as arguments.

The `...` argument let's you input a variety of unspecified arguments to a function, that are then passed to another function.

When calling a function you can use objects or expressions as input to an argument.


]

.pull-right45[

```{r}
# function definition
call_fun <- function(dat, fn, ...){
  fn(dat, ...)
}

# input a function and additional statements
call_fun(dat = pirates$parrots,
         fn = mean, na.rm = TRUE)

# input expression as argument
call_fun(pirates$weight /
           (pirates$height / 100) ** 2,
         fn = median, na.rm = TRUE)



```

]

---

# Functions - Error Messages

.pull-left45[

When writing functions you can add checks and if they are not met provide your own error messages.

Possible functions are `stop()`, `message()`, `warning()`, and `stopifnot()`.

- `stopifnot()` takes an unlimited number of assertions as input.
- With `stop()`, `message()`, and `warning()` you have to use separate `if` statements to test each potential violation. 


]

.pull-right45[

```{r}
# with stop you test whether stopping
# condition is met
divide <- function(dividend,
                   divisor){
  if (divisor == 0){
    stop("Cannot divide by 0.
         Enter another value for divisor.")
  }
  
  dividend / divisor
}

# with stopifnot you test an
# assertion and throws a generic
# error message
divide <- function(x, y){
  
  stopifnot(y != 0, !is.null(x),
            !is.null(y),
            all(!is.na(c(x, y))))
  
  x / y
}

```

]

---

# Iteration - `for` Loops

.pull-left45[

A for loop lets you repeat the execution of a block of code as many times as you wish. It also allows you to loop through positions.

A `for` loop has three components:

- output (object to be prepared before entering the loop)
- sequence (defines the vector to loop through)
- body (the code that does the actual work)


]

.pull-right45[

```{r}
for (i in seq_len(4)) {
  print(i)
}

pir_sub <- pirates %>%
  select(age, height, weight)

output <- vector(
  length = ncol(pir_sub)) #  output

for (i in seq_along(pir_sub)) { # sequence
  output[i] <- mean(pir_sub[[i]]) # body
}
output



```

]


---

# Iteration - `while` Loops


.pull-left45[

`while` loops let you iterate until a specified condition is met.

This can be handy, but also "dangerous" because if the condition is never met, it will just iterate until you manually stop it.


]

.pull-right45[


```{r, eval = FALSE}
trunc_norm <- rnorm(30)

# get normal dist trucated at 0
while(any(trunc_norm < 0)){
  trunc_norm <- rnorm(30)
}

# Potentially problematic:
# get normal dist trucated at 0
# but with a much larger sample
while(any(trunc_norm < 0)){
  trunc_norm <- rnorm(500)
}
```

]

---

# Iteration - `apply` Family


.pull-left45[

Functions of the `apply` family are another tool to iterate through objects and do the same operation on each subset.

They are very handy, but not always consistently programmed, i.e., for example the argument structure is not always the same.

These are available `apply` functions:

- `apply`
- `lapply`
- `sapply`
- `tapply`
- `vapply`


]

.pull-right45[


```{r}
# apply for rows or colums
apply(pir_sub[1:3,], 1, mean) # rows
apply(pir_sub, 2, mean) # columns

# sapply: simplest apply version
sapply(pir_sub, mean) # columns

```

]


---

# Iteration - `apply` Family


.pull-left45[

Functions of the `apply` family are another tool to iterate through objects and do the same operation on each subset.

They are very handy, but not always consistently programmed, i.e., for example the argument structure is not always the same.

These are available `apply` functions:

- `apply`
- `lapply`
- `sapply`
- `tapply`
- `vapply`


]

.pull-right45[


```{r}

# tapply: sapply with grouping variables
tapply(pirates$tattoos, pirates$sex, mean)

# vapply: safe apply version: must return
# a numeric vector of length 1
vapply(pir_sub, mean, 1) 

```

]

---

# Iteration - `apply` Family - Anonymous Functions


.pull-left45[


You can specify *anonymous functions* in functions of the `apply` family. 

An anonymous function exists only temporarily when the `apply` function is called. This means that the anonymous function is not defined in a separate step, but directly within the `apply` function.



]

.pull-right45[


```{r, eval = FALSE}

# rescale age, height, and sex
# from the pirates subset to be
# between 0 and 1
lapply(pir_sub, function(x, na_act){
  
  # first get the range
  rng <- range(x, na.rm = na_act)
  
  # then rescale
  (x - rng[1]) / (rng[2] - rng[1])
  
}, na_act = TRUE)


```

]

---

# Iteration - `map` Family


.pull-left45[


The `map` functions are the purrr equivalent of the `apply` functions.

```{r, echo = FALSE, out.width = "60%", fig.align = 'center'}
knitr::include_graphics("https://raw.githubusercontent.com/therbootcamp/therbootcamp.github.io/master/_sessions/_image/purrr_hex.png")
```

]

.pull-right45[


```{r}

map(pir_sub, mean)

map_dbl(pir_sub, mean)


```

]

---

# Iteration - `map` Family


.pull-left45[


The `map` functions are the purrr equivalent of the `apply` functions.

There are several `map` functions that iterate over one vector. They are named after the type of object they return:

- `map` returns a list
- `map_lgl` returns a logical vector
- `map_int` returns an integer vector
- `map_dbl` returns a double vector
- `map_chr` returns a character vector

```{r, echo = FALSE, out.width = "20%", fig.align = 'center'}
knitr::include_graphics("https://raw.githubusercontent.com/therbootcamp/therbootcamp.github.io/master/_sessions/_image/purrr_hex.png")
```

]

.pull-right45[


```{r}

pirates %>%
  select(age,
         tattoos,
         beard.length)  %>%
  map_dbl(function(x){
    sum(x) / length(x)
  })


```

]


---

# Iteration - `map` Family


.pull-left45[


The `map` functions are the purrr equivalent of the `apply` functions.

There are also `map` functions that iterate over two or more vectors. 

They are named `map2`, and `pmap`.

If the objects in the list are named, pmap will use the name, otherwise the position in the list, to determine which object belongs to which argument.

```{r, echo = FALSE, out.width = "20%", fig.align = 'center'}
knitr::include_graphics("https://raw.githubusercontent.com/therbootcamp/therbootcamp.github.io/master/_sessions/_image/purrr_hex.png")
```

]

.pull-right45[


```{r}
mus <- c(4, 5)
sds <- c(2, 3)

map2(mus, sds, rnorm, n = 3)

ns <- c(2, 3)

pmap(list(mean = mus,
          sd = sds,
          n = ns), rnorm)
```

]



---

# Iteration - `map` Family


.pull-left45[


The `map` functions are the purrr equivalent of the `apply` functions.

You can not only iterate through objects to use as arguments but also through functions. This is done with `invoke_map`.

```{r, echo = FALSE, out.width = "20%", fig.align = 'center'}
knitr::include_graphics("https://raw.githubusercontent.com/therbootcamp/therbootcamp.github.io/master/_sessions/_image/purrr_hex.png")
```

]

.pull-right45[


```{r}
# list with the arguments
argumnts <- list(
  list(mean = 4, sd = 2),
  list(shape1 = 2, shape2 = 3)
)

# vector of functions
functs <- c("rnorm", "rbeta")

invoke_map(functs, argumnts, n = 3)


```

]


---

# Summary - What We've Learned


- How to use conditional statements
- How to program our own functions
- How to iterate over blocks of code

This is very helpful to not having to type the same code many times and to keep it more flexible. Remember the DRY (Don't Repeat Yourself) principle, i.e. if you have to write the same block of code more than twice, create a function to do so and iterate over it.



---

# Programming in R Practical

<p><font size=6><b><a href="https://therbootcamp.github.io/BaselRBootcamp_2018April/_sessions/D4S1_ProgrammingInR/Programming_in_R_practical.html">Link to practical</a>

